classdef (Abstract) planarDetector < surfaceDetection.surfaceDetector
    % planarDetector Extract a surface point cloud from a planar data stack
    %
    % As opposed to other detectors, the detected surface is
    % represented not only by a PointCloud object but also by an image
    % surfaceMatrix, containing z values for each xy
    
    %---------------------------------------------------------------------
    % license
    %---------------------------------------------------------------------

    % Copyright 2015 Idse Heemskerk and Sebastian Streichan
    %
    % This file is part of ImSAnE.
    % 
    % ImSAnE is free software: you can redistribute it and/or modify
    % it under the terms of the GNU General Public License as published by
    % the Free Software Foundation, either version 3 of the License, or
    % (at your option) any later version.
    % 
    % ImSAnE is distributed in the hope that it will be useful,
    % but WITHOUT ANY WARRANTY; without even the implied warranty of
    % MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    % GNU General Public License for more details.
    % 
    % You should have received a copy of the GNU General Public License
    % along with ImSAnE.  If not, see <http://www.gnu.org/licenses/>.
    %
    % We make an explicit exception giving permission to link this code
    % with GPL-incompatible matlab facilities.
    
    %---------------------------------------------------------------------
    % properties
    %---------------------------------------------------------------------
    
    properties (SetAccess = protected)
        surfaceMatrix   % height of surface image (maximal z-derivative)
        summedI         % summed intensity used for mask
        maxI            % max intensity projection of the stack
        manualMask      % mask generated by the user
        mask            % mask on the surface matrix
    end
    
    %---------------------------------------------------------------------
    % protected methods
    %---------------------------------------------------------------------
      
    methods %(Access = protected)
        
        function updatePointCloud(this)
            % UPDATEPOINTCLOUD update point cloud based on surface matrix
            %
            % updatePointCloud() 

            Z = this.surfaceMatrix(this.mask);
            [X,Y] = meshgrid(1:size(this.mask, 2), 1:size(this.mask, 1));
            points = [X(this.mask), Y(this.mask), Z];
            this.pointCloud.setPoints(points);
        end
    end 
    
    %---------------------------------------------------------------------
    % public methods
    %---------------------------------------------------------------------    
    
    methods
         
        % ------------------------------------------------------
        % constructor
        % ------------------------------------------------------
        
        function this = planarDetector()
            % PLANARDETECTOR Create a new planarDetector
            %
            % planarDetector()
            
            this = this@surfaceDetection.surfaceDetector();
        end 
        
        % ------------------------------------------------------
        % masks
        % ------------------------------------------------------
        
        function applyMasks(this)
            % APPLYMASKS Create mask for surfaceMatrix and mask pointCloud
            %
            % applyMasks()
            %
            % Masks consist of manual mask set with setManualMask and mask
            % generated from different filters set in detector options,
            % the goal is to only keep the detected points on the SOI
            %
            % see also surfaceDetection.planarDetector.setManualMask
            
            if ~isempty(this.manualMask)
                this.mask = this.manualMask;
            else
                this.mask = true(size(this.surfaceMatrix));
            end
            
            opts = this.options;
            
            %-----------------------------------------
            % initial masking
            %-----------------------------------------
            
            % maximal intensity threshold
            % scaled
            if opts.maxIthresh > 0 && opts.maxIthresh <= 1 
                
                maxImask = mat2gray(this.maxI) > opts.maxIthresh;
                this.mask = this.mask & maxImask;
            
            % or absolute   
            elseif opts.maxIthresh > 1
                
                maxImask = this.maxI > opts.maxIthresh;
                this.mask = this.mask & maxImask;
            end
            
            % summed intensity threshold
            % scaled
            if opts.summedIthresh > 0 && opts.summedIthresh <= 1

                sumImask = this.summedI/max(this.summedI(:)) > opts.summedIthresh;
                this.mask = this.mask & sumImask;
            
            % or absolute
            elseif opts.summedIthresh > 1
                
                sumImask = this.summedI > opts.summedIthresh;
                this.mask = this.mask & sumImask;
            end
            
            % remove single pixels
            this.mask = bwmorph(this.mask, 'clean');
            this.mask = bwareaopen(this.mask, 5);
            
            %-----------------------------------------
            % z-outlier removal after initial masking
            %-----------------------------------------
            
            if opts.sigZoutliers > 0 && opts.scaleZoutliers > 0
                
                scale = opts.scaleZoutliers;
                nSigZ = opts.sigZoutliers;
                
                % implement an average over non-zero values:
                h = fspecial('average', scale);
                norm = imfilter(mat2gray(this.mask), h);
                avgZ = imfilter(this.surfaceMatrix.*this.mask, h);
                avgZ = avgZ./norm;
                avgZ(norm == 0) = 0;
                
                % standard devatiation of non-zero values
                devSq = (avgZ - this.surfaceMatrix).^2;
                sigZ = sqrt(imfilter(devSq.*this.mask, h)./norm);
                sigZ(norm == 0) = 0;
                
                % remove outliers
                outlierMask = (this.surfaceMatrix < avgZ + nSigZ*sigZ)...
                           & (this.surfaceMatrix > avgZ - nSigZ*sigZ);
                
                this.mask = this.mask & outlierMask;
            end
            
            %-----------------------------------------
            % update point cloud
            %-----------------------------------------
            
            this.updatePointCloud();
        end
        
        function resetMask(this)
            % RESETMASK Remove masks applied to pointCloud
            % 
            % resetMask
            %
            % manual mask and filter generated masks are not erased and can
            % be set again with applyMasks
            %
            % see also surfaceDetection.planarDetector.applyMasks
            
            this.mask = true(size(this.mask));
            this.manualMask = true(size(this.mask));
            this.updatePointCloud();
        end
        
        function setManualMask(this, mask)
            % SETMANUALMASK Set a manual mask the size of surfaceMatrix
            %
            % This mask can be applied to to the pointCloud with applyMasks
            %
            % see also surfaceDetection.planarDetector.applyMasks
            
            if isempty(this.surfaceMatrix)
                error('please run detectSurface first');
            end
            
            if ~all(size(mask) == size(this.surfaceMatrix))
                error('manual mask size should match surfaceMatrix');
            end
            
           	this.manualMask = mask; 
        end

    end

end